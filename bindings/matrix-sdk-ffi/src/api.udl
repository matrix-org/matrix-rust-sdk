namespace matrix_sdk_ffi {};


/// Cancels on drop
interface StoppableSpawn {};

[Error]
interface ClientError {
    Generic(string msg);
};

callback interface ClientDelegate {
    void did_receive_sync_update();
    void did_receive_auth_error(boolean is_soft_logout);
    void did_update_restore_token();
};

dictionary RequiredState {
    string key;
    string value;
};

dictionary RoomSubscription {
    sequence<RequiredState>? required_state;
    u32? timeline_limit;
};

dictionary UpdateSummary {
    sequence<string> views;
    sequence<string> rooms;
};

callback interface SlidingSyncObserver {
    void did_receive_sync_update(UpdateSummary summary);
};

enum SlidingSyncState {
    /// Hasn't started yet
    "Cold",
    /// We are quickly preloading a preview of the most important rooms
    "Preload",
    /// We are trying to load all remaining rooms, might be in batches
    "CatchingUp",
    /// We are all caught up and now only sync the live responses.
    "Live",
};

enum SlidingSyncMode {
    /// Sync up the entire room list first
    "FullSync",
    /// Only ever sync the currently selected window
    "Selective",
};

callback interface SlidingSyncViewStateObserver {
    void did_receive_update(SlidingSyncState new_state);
};

[Enum]
interface RoomListEntry {
    Empty();
    Invalidated(string room_id);
    Filled(string room_id);
};

[Enum]
interface SlidingSyncViewRoomsListDiff {
    Replace(sequence<RoomListEntry> values);
    InsertAt(
        u32 index,
        RoomListEntry value
    );
    UpdateAt(
        u32 index,
        RoomListEntry value
    );
    RemoveAt(u32 index);
    Move(
        u32 old_index,
        u32 new_index
    );
    Push(RoomListEntry value);
    // The following are supported by the generic VecDiff-type but
    // in sliding sync effectively do not happen and thus aren't exposed
    // to not pollute the API: Pop(); Clear();
};

callback interface SlidingSyncViewRoomListObserver {
    void did_receive_update(SlidingSyncViewRoomsListDiff diff);
};

callback interface SlidingSyncViewRoomsCountObserver {
    void did_receive_update(u32 count);
};

callback interface SlidingSyncViewRoomItemsObserver {
    void did_receive_update();
};

interface SlidingSyncViewBuilder {
    constructor();

    [Self=ByArc]
    SlidingSyncViewBuilder sync_mode(SlidingSyncMode mode);

    [Self=ByArc]
    SlidingSyncViewBuilder required_state(sequence<RequiredState> required_state);

    [Throws=ClientError, Self=ByArc]
    SlidingSyncView build();
};

interface SlidingSyncView {
    StoppableSpawn observe_room_list(SlidingSyncViewRoomListObserver observer);
    StoppableSpawn observe_rooms_count(SlidingSyncViewRoomsCountObserver observer);
    StoppableSpawn observe_state(SlidingSyncViewStateObserver observer);
    StoppableSpawn observe_room_items(SlidingSyncViewRoomItemsObserver observer);

    sequence<RoomListEntry> current_rooms_list();
};

interface SlidingSyncRoom {};

interface SlidingSync {
    void set_observer(SlidingSyncObserver? observer);

    [Throws=ClientError]
    void subscribe(string room_id, RoomSubscription? settings);
    [Throws=ClientError]
    void unsubscribe(string room_id);

    SlidingSyncView? get_view(string name);
    [Throws=ClientError]
    SlidingSyncRoom? get_room(string room_id);
    [Throws=ClientError]
    sequence<SlidingSyncRoom?> get_rooms(sequence<string> room_ids);
};

interface ClientBuilder {
    constructor();

    [Throws=ClientError, Self=ByArc]
    Client build();
};

interface SlidingSyncBuilder {
    [Throws=ClientError, Self=ByArc]
    SlidingSyncBuilder homeserver(string url);

    [Throws=ClientError, Self=ByArc]
    SlidingSync build();
};

interface Client {
    void set_delegate(ClientDelegate? delegate);

    [Throws=ClientError]
    void login(string username, string password, string? initial_device_name, string? device_id);

    [Throws=ClientError]
    void restore_login(string restore_token);

    [Throws=ClientError]
    string restore_token();

    [Throws=ClientError]
    string user_id();

    [Throws=ClientError]
    string display_name();

    [Throws=ClientError]
    string avatar_url();

    [Throws=ClientError]
    string device_id();

    [Throws=ClientError]
    string? account_data(string event_type);

    [Throws=ClientError]
    void set_account_data(string event_type, string content);

    [Throws=ClientError]
    sequence<u8> get_media_content(MediaSource source);

    [Throws=ClientError]
    sequence<u8> get_media_thumbnail(MediaSource source, u64 width, u64 height);

    [Throws=ClientError]
    SessionVerificationController get_session_verification_controller();

    [Throws=ClientError]
    SlidingSync full_sliding_sync();

    [Throws=ClientError]
    void logout();
};

interface Room {
    [Throws=ClientError]
    string display_name();

    [Throws=ClientError]
    string? member_avatar_url(string user_id);

    [Throws=ClientError]
    string? member_display_name(string user_id);

    void add_timeline_listener(TimelineListener listener);

    // Loads older messages into the timeline.
    //
    // Raises an exception if there are no timeline listeners.
    [Throws=ClientError]
    PaginationOutcome paginate_backwards(u16 limit);

    [Throws=ClientError]
    void send(RoomMessageEventContent msg, string? txn_id);

    [Throws=ClientError]
    void send_reply(string msg, string in_reply_to_event_id, string? txn_id);

    [Throws=ClientError]
    void redact(string event_id, string? reason, string? txn_id);
};

callback interface TimelineListener {
    void on_update(TimelineDiff update);
};

interface TimelineDiff {
    [Self=ByArc]
    sequence<TimelineItem>? replace();
    [Self=ByArc]
    InsertAtData? insert_at();
    [Self=ByArc]
    UpdateAtData? update_at();
    u32? remove_at();
    MoveData? move();
    [Self=ByArc]
    TimelineItem? push();
};

dictionary InsertAtData {
    u32 index;
    TimelineItem item;
};

dictionary UpdateAtData {
    u32 index;
    TimelineItem item;
};

dictionary MoveData {
    u32 old_index;
    u32 new_index;
};

interface TimelineItem {};

interface EventTimelineItem {
    sequence<Reaction> reactions();
};

// Other methods defined via proc-macro
interface Message {
    MessageType? msgtype();
};

[Enum]
interface MessageType {
    Emote(EmoteMessageContent content);
    Image(ImageMessageContent content);
    Notice(NoticeMessageContent content);
    Text(TextMessageContent content);
};

dictionary EmoteMessageContent {
    string body;
    FormattedBody? formatted;
};

dictionary ImageMessageContent {
    string body;
    MediaSource source;
    ImageInfo? info;
};

dictionary ImageInfo {
    u64? height;
    u64? width;
    string? mimetype;
    u64? size;
    ThumbnailInfo? thumbnail_info;
    MediaSource? thumbnail_source;
    string? blurhash;
};

dictionary ThumbnailInfo {
    u64? height;
    u64? width;
    string? mimetype;
    u64? size;
};

dictionary NoticeMessageContent {
    string body;
    FormattedBody? formatted;
};

dictionary TextMessageContent {
    string body;
    FormattedBody? formatted;
};

dictionary FormattedBody {
    MessageFormat format;
    string body;
};

enum MessageFormat {
    "Html",
    "Unknown",
};

dictionary Reaction {
    string key;
    u64 count;
    // senders to come
};

dictionary PaginationOutcome {
    // Whether there's more messages to be paginated.
    boolean more_messages;
};

interface RoomMessageEventContent {};

interface MediaSource {
    string url();
};

[Error]
enum AuthenticationError {
    "ClientMissing",
    "SessionMissing",
    "Generic",
};

interface AuthenticationService {
    constructor(string base_path);

    [Throws=AuthenticationError]
    void configure_homeserver(string server_name);

    [Throws=AuthenticationError]
    Client login(string username, string password, string? initial_device_name, string? device_id);

    [Throws=AuthenticationError]
    Client restore_with_access_token(string token, string device_id);
};

interface SessionVerificationEmoji {};

callback interface SessionVerificationControllerDelegate {
    void did_receive_verification_data(sequence<SessionVerificationEmoji> data);
    void did_fail();
    void did_cancel();
    void did_finish();
};

interface SessionVerificationController {
    void set_delegate(SessionVerificationControllerDelegate? delegate);

    [Throws=ClientError]
    void request_verification();

    [Throws=ClientError]
    void approve_verification();

    [Throws=ClientError]
    void decline_verification();

    [Throws=ClientError]
    void cancel_verification();
};
